//! Action types for the safety pipeline.
//!
//! Actions represent operations that agents want to perform. They flow through
//! the safety pipeline where they are validated, potentially approved, and executed.

use crate::id::{ActionId, AgentId, ToolCallId};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::fmt;

/// The type of action being performed
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ActionType {
    /// Invoke a tool
    ToolCall {
        /// Name of the tool
        tool_name: String,
        /// Tool call ID for tracking
        tool_call_id: ToolCallId,
    },

    /// Send a message
    Message {
        /// Target agent (None for user)
        recipient: Option<AgentId>,
    },

    /// Modify internal state
    StateChange {
        /// Type of state change
        change_type: String,
    },

    /// External API call or effect
    External {
        /// Target service or resource
        target: String,
        /// HTTP method if applicable
        method: Option<String>,
    },

    /// File system operation
    FileSystem {
        /// Operation type
        operation: FileOperation,
        /// Target path
        path: String,
    },

    /// Shell command execution
    Shell {
        /// Command to execute
        command: String,
        /// Working directory
        cwd: Option<String>,
    },
}

/// File system operation types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FileOperation {
    /// Read a file
    Read,
    /// Write to a file
    Write,
    /// Append to a file
    Append,
    /// Delete a file
    Delete,
    /// Create a directory
    CreateDir,
    /// List directory contents
    ListDir,
    /// Move/rename a file
    Move,
    /// Copy a file
    Copy,
}

impl FileOperation {
    /// Check if this operation modifies the file system
    pub fn is_mutating(&self) -> bool {
        !matches!(self, FileOperation::Read | FileOperation::ListDir)
    }

    /// Check if this operation is destructive (hard to undo)
    pub fn is_destructive(&self) -> bool {
        matches!(self, FileOperation::Delete)
    }
}

/// Source of an action
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "source_type", rename_all = "snake_case")]
pub enum ActionSource {
    /// Generated by LLM
    LlmGenerated {
        /// Model that generated the action
        model: String,
    },
    /// User requested
    UserRequested,
    /// System triggered (e.g., scheduled task)
    SystemTriggered {
        /// Trigger reason
        reason: String,
    },
    /// Delegated from another agent
    Delegated {
        /// Source agent
        from_agent: AgentId,
    },
}

/// An action to be performed by an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Action {
    /// Unique action ID
    pub id: ActionId,
    /// Type of action
    pub action_type: ActionType,
    /// Parameters for the action
    pub parameters: Value,
    /// Source of this action
    pub source: ActionSource,
    /// When the action was created
    pub timestamp: DateTime<Utc>,
    /// Priority level
    pub priority: Priority,
    /// Maximum time to wait for execution
    pub timeout: Option<std::time::Duration>,
}

impl Action {
    /// Create a new action
    pub fn new(action_type: ActionType, parameters: Value, source: ActionSource) -> Self {
        Self {
            id: ActionId::new(),
            action_type,
            parameters,
            source,
            timestamp: Utc::now(),
            priority: Priority::Normal,
            timeout: None,
        }
    }

    /// Create a tool call action
    pub fn tool_call(
        tool_name: impl Into<String>,
        tool_call_id: ToolCallId,
        parameters: Value,
        source: ActionSource,
    ) -> Self {
        Self::new(
            ActionType::ToolCall {
                tool_name: tool_name.into(),
                tool_call_id,
            },
            parameters,
            source,
        )
    }

    /// Create a file system action
    pub fn file_system(
        operation: FileOperation,
        path: impl Into<String>,
        parameters: Value,
        source: ActionSource,
    ) -> Self {
        Self::new(
            ActionType::FileSystem {
                operation,
                path: path.into(),
            },
            parameters,
            source,
        )
    }

    /// Create a shell command action
    pub fn shell(
        command: impl Into<String>,
        cwd: Option<String>,
        parameters: Value,
        source: ActionSource,
    ) -> Self {
        Self::new(
            ActionType::Shell {
                command: command.into(),
                cwd,
            },
            parameters,
            source,
        )
    }

    /// Set the priority of this action
    pub fn with_priority(mut self, priority: Priority) -> Self {
        self.priority = priority;
        self
    }

    /// Set the timeout for this action
    pub fn with_timeout(mut self, timeout: std::time::Duration) -> Self {
        self.timeout = Some(timeout);
        self
    }

    /// Check if this action is potentially destructive
    pub fn is_potentially_destructive(&self) -> bool {
        match &self.action_type {
            ActionType::FileSystem { operation, .. } => operation.is_destructive(),
            ActionType::Shell { .. } => true, // Shell commands are always potentially destructive
            ActionType::External { .. } => true,
            _ => false,
        }
    }

    /// Check if this action modifies state
    pub fn is_mutating(&self) -> bool {
        match &self.action_type {
            ActionType::FileSystem { operation, .. } => operation.is_mutating(),
            ActionType::Shell { .. } => true,
            ActionType::External { .. } => true,
            ActionType::StateChange { .. } => true,
            _ => false,
        }
    }

    /// Get a description of this action for logging
    pub fn description(&self) -> String {
        match &self.action_type {
            ActionType::ToolCall { tool_name, .. } => format!("tool_call:{}", tool_name),
            ActionType::Message { recipient } => match recipient {
                Some(id) => format!("message:agent:{}", id),
                None => "message:user".to_string(),
            },
            ActionType::StateChange { change_type } => format!("state_change:{}", change_type),
            ActionType::External { target, method } => {
                format!("external:{}:{}", method.as_deref().unwrap_or("GET"), target)
            }
            ActionType::FileSystem { operation, path } => format!("file:{:?}:{}", operation, path),
            ActionType::Shell { command, .. } => format!("shell:{}", &command[..command.len().min(50)]),
        }
    }
}

/// Priority level for actions
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Priority {
    /// Lowest priority
    Low,
    /// Normal priority (default)
    Normal,
    /// High priority
    High,
    /// Critical - execute immediately
    Critical,
}

impl Default for Priority {
    fn default() -> Self {
        Priority::Normal
    }
}

impl fmt::Display for Priority {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Priority::Low => write!(f, "low"),
            Priority::Normal => write!(f, "normal"),
            Priority::High => write!(f, "high"),
            Priority::Critical => write!(f, "critical"),
        }
    }
}

/// Result of an action execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActionResult {
    /// The action that was executed
    pub action_id: ActionId,
    /// Whether execution succeeded
    pub success: bool,
    /// Output from the action
    pub output: Option<Value>,
    /// Error message if failed
    pub error: Option<String>,
    /// Duration of execution
    pub duration: std::time::Duration,
    /// When execution completed
    pub completed_at: DateTime<Utc>,
}

impl ActionResult {
    /// Create a successful result
    pub fn success(action_id: ActionId, output: Value, duration: std::time::Duration) -> Self {
        Self {
            action_id,
            success: true,
            output: Some(output),
            error: None,
            duration,
            completed_at: Utc::now(),
        }
    }

    /// Create a failure result
    pub fn failure(action_id: ActionId, error: impl Into<String>, duration: std::time::Duration) -> Self {
        Self {
            action_id,
            success: false,
            output: None,
            error: Some(error.into()),
            duration,
            completed_at: Utc::now(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_action_creation() {
        let action = Action::tool_call(
            "read_file",
            ToolCallId::new(),
            serde_json::json!({"path": "/tmp/test.txt"}),
            ActionSource::UserRequested,
        );

        assert!(!action.is_potentially_destructive());
        assert!(action.description().starts_with("tool_call:read_file"));
    }

    #[test]
    fn test_destructive_action() {
        let action = Action::file_system(
            FileOperation::Delete,
            "/tmp/test.txt",
            Value::Null,
            ActionSource::UserRequested,
        );

        assert!(action.is_potentially_destructive());
        assert!(action.is_mutating());
    }

    #[test]
    fn test_action_priority() {
        assert!(Priority::Critical > Priority::High);
        assert!(Priority::High > Priority::Normal);
        assert!(Priority::Normal > Priority::Low);
    }
}
